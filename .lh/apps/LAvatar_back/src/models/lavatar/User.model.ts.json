{
    "sourceFile": "apps/LAvatar_back/src/models/lavatar/User.model.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1676018306961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1676019041876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-import crypto from 'crypto';\n import _ from 'lodash';\n import mongoose, {Connection, Schema, Model, Document} from 'mongoose';\n import bcrypt from 'bcrypt';\n import ERR from 'http-errors';\n"
                }
            ],
            "date": 1676018306961,
            "name": "Commit-0",
            "content": "import crypto from 'crypto';\nimport _ from 'lodash';\nimport mongoose, {Connection, Schema, Model, Document} from 'mongoose';\nimport bcrypt from 'bcrypt';\nimport ERR from 'http-errors';\nimport jwtHelper from '../../utils/jwtHelper';\nimport log from '../../utils/logger';\n\n\nconst SALT_WORK_FACTOR = 10;\n\nconst schemaName = 'User';\n\nconst schema = new Schema<UserDocument, UserModel>(\n    {\n        email: {type: String, unique: true, required: true},\n        username: {type: String},\n        password: {type: String, select: false},\n        last_login: {type: Date},\n        profile_img: {type: String},\n        settings: {type: Object},\n        permissions: {type: [String], select: false},\n    },\n    {\n        timestamps: {createdAt: 'created_at', updatedAt: 'updated_at'},\n        toJSON: {virtuals: true},\n    },\n);\n\ninterface User {\n    email: string;\n    username: string;\n    password?: string;\n    last_login?: Date;\n    profile_img: string;\n    settings?: UserSettings;\n    permissions: object;\n\n}\ninterface UserSettings {\n    locale?: string;\n    timezone?: string;\n}\nexport interface UserDocument extends User, Document {\n\n    comparePassword(candidatePassword: string): Promise<boolean>;\n\n    createAuthToken(withPermission?: any): string;\n}\n\nexport interface UserModel extends Model<UserDocument> {\n    getUser(email: string, password: string): any;\n\n    jwt_authenticate(email: string, password: string): any;\n}\n\n\n// Instance methods\nschema.methods.comparePassword = async function(candidatePassword: string) {\n    console.log('check password', candidatePassword, this.password);\n    const isMatch = await bcrypt.compare(candidatePassword, this.password as string);\n    console.log('isMatch', isMatch);\n\n    return isMatch;\n};\n\nschema.methods.createAuthToken = function(withPermission: string) {\n    const omitList = ['password'];\n    if (!withPermission) {\n        omitList.push('permissions');\n    } else {\n        log.warning('createAuthToken with permissions');\n    }\n    const payload = _.omit(this.toJSON(), omitList);\n    return jwtHelper.sign(payload);\n};\n\n// Static methods\nschema.statics.getUser = async function(email, password) {\n    const user = await this.jwt_authenticate(email, password);\n    if (!user) {\n        throw ERR(404, 'cannot found user');\n    } else {\n        return user;\n    }\n};\n\nschema.statics.jwt_authenticate = async function(email, password) {\n    const user = await this.findOne({email: email}).select('password');\n    if (!user) {\n        throw ERR(400, 'cannot found user by email');\n    }\n    if (bcrypt.compareSync(password, user.password as string)) {\n        console.log('success password is correct');\n        return _.omit(user.toJSON(), 'password');\n    } else {\n        throw ERR(400, 'password is wrong');\n    }\n};\n\nschema.statics.createGuestUser = async function(req) {\n    const ip = _.get(req, 'originalUrl');\n    if (ip) {\n        const existGuest = await this.findOne({isGuest: ip});\n        const pass = Math.random().toString(36).substring(8);\n        if (existGuest) {\n            return null;\n        } else {\n            const oid = new mongoose.Types.ObjectId().toString();\n            const newGuest = new this({\n                username: `Guest-${oid}`,\n                email: `Guest@${oid}.com`,\n                password: pass,\n            });\n            let guest: UserDocument | null = await newGuest.save();\n            guest = await this.findById(guest._id);\n            const guestInfo: any = _.pick(guest, ['email', 'username']);\n            guestInfo.password = pass;\n            return {\n                guest: guestInfo,\n                token: guest!.createAuthToken(),\n            };\n        }\n    }\n};\n\n// Hooks\n// @see: http://devsmash.com/blog/password-authentication-with-mongoose-and-bcrypt\nschema.pre('save', function(next) {\n    const user: UserDocument = this;\n    if (!user.username) {\n        user.username = _.get(user.email.match(/^([^@]*)@/), '1')!;\n    }\n\n    // only hash the password if it has been modified (or is new)\n    if (!user.isModified('password')) return next();\n\n    // generate a salt\n    bcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt) {\n        if (err) return next(err);\n\n        // hash the password along with our new salt\n        bcrypt.hash(user.password!, salt, function(err, hash) {\n            if (err) return next(err);\n\n            // override the cleartext password with the hashed one\n            user.password = hash;\n            next();\n        });\n    });\n});\nexport default function(connection: Connection) {\n    return (connection || mongoose).model<UserDocument, UserModel>(schemaName, schema, schemaName);\n}\n"
        }
    ]
}